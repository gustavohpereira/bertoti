# bertoti
<h1>engenharia de software 1</h1>

<p>We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play.   On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.<p>

Para um engenheiro de Software vários fatores influenciam na criação de um programa, tal como tempo, escala do programa, etc, sendo seu trabalho manejar os recursos dispostos a si da melhor maneira possível, tendo em conta todos os fatores citados acima. Isso, contudo, nem sempre será possível, devendo ele priorizar um ou outro fator dependendo do cenário em questão, por vezes tomando decisões baseadas em presunções imprecisas. Tais fatores servem para diferi-lo do programador, devendo o engenheiro de software ter uma visão mais completa e heuristica deste processo, buscando a criação do melhor produto possível apesar das adversidades.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

Existe uma diferença fundamental entre programadores e desenvolvedores de software, de modo que o primeiro foca na criação do código, enquanto o outro fica responsável por sua arquiterura, manutenção e estruturação. Em suma, apesar de suas tarefas interseccionarem em determinados pontos, ambos são fundamentalmente diferentes, tendo um maior responsabilidade na construção do programa que o outro, apesar de ambos serem importantes para o todo.


<h2>2. O que são requisitos?</h2>
R - são as necessidades do cliente, não envolvendo nenhum desejo pessoal por parte do programador e desenvolvedor, somente tendo em vista as necessidades do cliente

<h3>2.1. Requisitos funcionais:</h3>
R- necessidades do cliente que podem ser expressas em verbos, ou seja, ações e funcionalidades do programa

<h3>2.2 Requisitos não funcionais:</h3>
R- necessidades do cliente que se assemelham com adjetivos ou qualidades do programa, sendo um aspecto do projeto do que uma ação que ele faz

<h2>Desafio</h2>
<h3>escreva 2 exemplos de trade-offs envolvendo requisitos não funcionais</h3>
R-  ESCALABILIDADE - muito tempo para implementar, planejamento, treinamento / segurança do codigo a longo prazo e otimização
    RASTREABILIDADE - custo, tempo de implementação / facilidade de manutenção e de supervisão
    
<h2>Codigo UML</h2>
<h3>esta na pasta projetoSlide do repositorio</h3>
